{"ast":null,"code":"export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? \"Choose date, selected date is \".concat(utils.format(utils.date(rawValue), 'fullDate')) : 'Choose date';\n}\nexport var getDisplayDate = function getDisplayDate(utils, rawValue, inputFormat) {\n  var date = utils.date(rawValue);\n  var isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nvar MASK_USER_INPUT_SYMBOL = '_';\nvar staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nvar staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  var formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  var inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  var inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  var isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    var defaultWarning = [\"The mask \\\"\".concat(mask, \"\\\" you passed is not valid for the format used \").concat(format, \".\"), \"Falling down to uncontrolled no-mask input.\"];\n\n    if (format.includes('MMM')) {\n      console.warn([].concat(defaultWarning, [\"Mask does not support literals such as 'MMM'.\", \"Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop\"]).join('\\n'));\n    } else if (inferredFormatPatternWith2Digits !== mask && inferredFormatPatternWith1Digits === mask) {\n      console.warn([].concat(defaultWarning, [\"Mask does not support numbers with variable length such as 'M'.\", \"Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop\"]).join('\\n'));\n    } else {\n      console.warn(defaultWarning.join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\nexport var maskedDateFormatter = function maskedDateFormatter(mask, acceptRegexp) {\n  return function (value) {\n    var outputCharIndex = 0;\n    return value.split('').map(function (char, inputCharIndex) {\n      acceptRegexp.lastIndex = 0;\n\n      if (outputCharIndex > mask.length - 1) {\n        return '';\n      }\n\n      var maskChar = mask[outputCharIndex];\n      var nextMaskChar = mask[outputCharIndex + 1];\n      var acceptedChar = acceptRegexp.test(char) ? char : '';\n      var formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n      outputCharIndex += formattedChar.length;\n      var isLastCharacter = inputCharIndex === value.length - 1;\n\n      if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n        // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n        return formattedChar ? formattedChar + nextMaskChar : '';\n      }\n\n      return formattedChar;\n    }).join('');\n  };\n};","map":{"version":3,"names":["getTextFieldAriaText","rawValue","utils","isValid","date","format","getDisplayDate","inputFormat","isEmpty","formatByString","MASK_USER_INPUT_SYMBOL","staticDateWith2DigitTokens","staticDateWith1DigitTokens","checkMaskIsValidForCurrentFormat","mask","acceptRegex","formattedDateWith1Digit","inferredFormatPatternWith1Digits","replace","inferredFormatPatternWith2Digits","isMaskValid","lib","process","env","NODE_ENV","defaultWarning","includes","console","warn","join","maskedDateFormatter","acceptRegexp","value","outputCharIndex","split","map","char","inputCharIndex","lastIndex","length","maskChar","nextMaskChar","acceptedChar","test","formattedChar","isLastCharacter"],"sources":["/Users/yoonjieun/Documents/공부/jei_react_project/node_modules/@mui/x-date-pickers/internals/utils/text-field-helper.js"],"sourcesContent":["export function getTextFieldAriaText(rawValue, utils) {\n  // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), 'fullDate')}` : 'Choose date';\n}\nexport const getDisplayDate = (utils, rawValue, inputFormat) => {\n  const date = utils.date(rawValue);\n  const isEmpty = rawValue === null;\n\n  if (isEmpty) {\n    return '';\n  }\n\n  return utils.isValid(date) ? utils.formatByString( // TODO: should `isValid` narrow `TDate | null` to `NonNullable<TDate>`?\n  // Either we allow `TDate | null` to be valid and guard against calling `formatByString` with `null`.\n  // Or we ensure `formatByString` is callable with `null`.\n  date, inputFormat) : '';\n};\nconst MASK_USER_INPUT_SYMBOL = '_';\nconst staticDateWith2DigitTokens = '2019-11-21T22:30:00.000';\nconst staticDateWith1DigitTokens = '2019-01-01T09:00:00.000';\nexport function checkMaskIsValidForCurrentFormat(mask, format, acceptRegex, utils) {\n  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format);\n  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);\n  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format).replace(acceptRegex, '_');\n  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;\n\n  if (!isMaskValid && utils.lib !== 'luxon' && process.env.NODE_ENV !== 'production') {\n    const defaultWarning = [`The mask \"${mask}\" you passed is not valid for the format used ${format}.`, `Falling down to uncontrolled no-mask input.`];\n\n    if (format.includes('MMM')) {\n      console.warn([...defaultWarning, `Mask does not support literals such as 'MMM'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else if (inferredFormatPatternWith2Digits !== mask && inferredFormatPatternWith1Digits === mask) {\n      console.warn([...defaultWarning, `Mask does not support numbers with variable length such as 'M'.`, `Either use numbers with fix length or disable mask feature with 'disableMaskedInput' prop`].join('\\n'));\n    } else {\n      console.warn(defaultWarning.join('\\n'));\n    }\n  }\n\n  return isMaskValid;\n}\nexport const maskedDateFormatter = (mask, acceptRegexp) => value => {\n  let outputCharIndex = 0;\n  return value.split('').map((char, inputCharIndex) => {\n    acceptRegexp.lastIndex = 0;\n\n    if (outputCharIndex > mask.length - 1) {\n      return '';\n    }\n\n    const maskChar = mask[outputCharIndex];\n    const nextMaskChar = mask[outputCharIndex + 1];\n    const acceptedChar = acceptRegexp.test(char) ? char : '';\n    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;\n    outputCharIndex += formattedChar.length;\n    const isLastCharacter = inputCharIndex === value.length - 1;\n\n    if (isLastCharacter && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {\n      // when cursor at the end of mask part (e.g. month) prerender next symbol \"21\" -> \"21/\"\n      return formattedChar ? formattedChar + nextMaskChar : '';\n    }\n\n    return formattedChar;\n  }).join('');\n};"],"mappings":"AAAA,OAAO,SAASA,oBAAT,CAA8BC,QAA9B,EAAwCC,KAAxC,EAA+C;EACpD;EACA;EACA;EACA,OAAOD,QAAQ,IAAIC,KAAK,CAACC,OAAN,CAAcD,KAAK,CAACE,IAAN,CAAWH,QAAX,CAAd,CAAZ,2CAAmFC,KAAK,CAACG,MAAN,CAAaH,KAAK,CAACE,IAAN,CAAWH,QAAX,CAAb,EAAmC,UAAnC,CAAnF,IAAsI,aAA7I;AACD;AACD,OAAO,IAAMK,cAAc,GAAG,SAAjBA,cAAiB,CAACJ,KAAD,EAAQD,QAAR,EAAkBM,WAAlB,EAAkC;EAC9D,IAAMH,IAAI,GAAGF,KAAK,CAACE,IAAN,CAAWH,QAAX,CAAb;EACA,IAAMO,OAAO,GAAGP,QAAQ,KAAK,IAA7B;;EAEA,IAAIO,OAAJ,EAAa;IACX,OAAO,EAAP;EACD;;EAED,OAAON,KAAK,CAACC,OAAN,CAAcC,IAAd,IAAsBF,KAAK,CAACO,cAAN,EAAsB;EACnD;EACA;EACAL,IAH6B,EAGvBG,WAHuB,CAAtB,GAGc,EAHrB;AAID,CAZM;AAaP,IAAMG,sBAAsB,GAAG,GAA/B;AACA,IAAMC,0BAA0B,GAAG,yBAAnC;AACA,IAAMC,0BAA0B,GAAG,yBAAnC;AACA,OAAO,SAASC,gCAAT,CAA0CC,IAA1C,EAAgDT,MAAhD,EAAwDU,WAAxD,EAAqEb,KAArE,EAA4E;EACjF,IAAMc,uBAAuB,GAAGd,KAAK,CAACO,cAAN,CAAqBP,KAAK,CAACE,IAAN,CAAWQ,0BAAX,CAArB,EAA6DP,MAA7D,CAAhC;EACA,IAAMY,gCAAgC,GAAGD,uBAAuB,CAACE,OAAxB,CAAgCH,WAAhC,EAA6CL,sBAA7C,CAAzC;EACA,IAAMS,gCAAgC,GAAGjB,KAAK,CAACO,cAAN,CAAqBP,KAAK,CAACE,IAAN,CAAWO,0BAAX,CAArB,EAA6DN,MAA7D,EAAqEa,OAArE,CAA6EH,WAA7E,EAA0F,GAA1F,CAAzC;EACA,IAAMK,WAAW,GAAGD,gCAAgC,KAAKL,IAArC,IAA6CG,gCAAgC,KAAKH,IAAtG;;EAEA,IAAI,CAACM,WAAD,IAAgBlB,KAAK,CAACmB,GAAN,KAAc,OAA9B,IAAyCC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAtE,EAAoF;IAClF,IAAMC,cAAc,GAAG,sBAAcX,IAAd,4DAAmET,MAAnE,sDAAvB;;IAEA,IAAIA,MAAM,CAACqB,QAAP,CAAgB,KAAhB,CAAJ,EAA4B;MAC1BC,OAAO,CAACC,IAAR,CAAa,UAAIH,cAAJ,kJAAkKI,IAAlK,CAAuK,IAAvK,CAAb;IACD,CAFD,MAEO,IAAIV,gCAAgC,KAAKL,IAArC,IAA6CG,gCAAgC,KAAKH,IAAtF,EAA4F;MACjGa,OAAO,CAACC,IAAR,CAAa,UAAIH,cAAJ,oKAAoLI,IAApL,CAAyL,IAAzL,CAAb;IACD,CAFM,MAEA;MACLF,OAAO,CAACC,IAAR,CAAaH,cAAc,CAACI,IAAf,CAAoB,IAApB,CAAb;IACD;EACF;;EAED,OAAOT,WAAP;AACD;AACD,OAAO,IAAMU,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAChB,IAAD,EAAOiB,YAAP;EAAA,OAAwB,UAAAC,KAAK,EAAI;IAClE,IAAIC,eAAe,GAAG,CAAtB;IACA,OAAOD,KAAK,CAACE,KAAN,CAAY,EAAZ,EAAgBC,GAAhB,CAAoB,UAACC,IAAD,EAAOC,cAAP,EAA0B;MACnDN,YAAY,CAACO,SAAb,GAAyB,CAAzB;;MAEA,IAAIL,eAAe,GAAGnB,IAAI,CAACyB,MAAL,GAAc,CAApC,EAAuC;QACrC,OAAO,EAAP;MACD;;MAED,IAAMC,QAAQ,GAAG1B,IAAI,CAACmB,eAAD,CAArB;MACA,IAAMQ,YAAY,GAAG3B,IAAI,CAACmB,eAAe,GAAG,CAAnB,CAAzB;MACA,IAAMS,YAAY,GAAGX,YAAY,CAACY,IAAb,CAAkBP,IAAlB,IAA0BA,IAA1B,GAAiC,EAAtD;MACA,IAAMQ,aAAa,GAAGJ,QAAQ,KAAK9B,sBAAb,GAAsCgC,YAAtC,GAAqDF,QAAQ,GAAGE,YAAtF;MACAT,eAAe,IAAIW,aAAa,CAACL,MAAjC;MACA,IAAMM,eAAe,GAAGR,cAAc,KAAKL,KAAK,CAACO,MAAN,GAAe,CAA1D;;MAEA,IAAIM,eAAe,IAAIJ,YAAnB,IAAmCA,YAAY,KAAK/B,sBAAxD,EAAgF;QAC9E;QACA,OAAOkC,aAAa,GAAGA,aAAa,GAAGH,YAAnB,GAAkC,EAAtD;MACD;;MAED,OAAOG,aAAP;IACD,CApBM,EAoBJf,IApBI,CAoBC,EApBD,CAAP;EAqBD,CAvBkC;AAAA,CAA5B"},"metadata":{},"sourceType":"module"}